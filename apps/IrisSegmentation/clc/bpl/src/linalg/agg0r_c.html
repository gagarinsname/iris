<html><head>
<meta http-equiv="content-type" content="text/html; charset=windows-1251">

<title>БЧА НИВЦ МГУ. AGG0R_C. Обобщенная проблема собственных значений
       для матриц общего вида</title>
<link rel="stylesheet" href="agg0r_c_files/sub_dsc.css" type="text/css">
<script charset="utf-8" id="injection_graph_func" src="agg0r_c_files/injection_graph_func.js"></script><script id="_nameHighlight_injection"></script><link class="skype_name_highlight_style" href="agg0r_c_files/injection_nh_graph.css" type="text/css" rel="stylesheet" charset="utf-8" id="_injection_graph_nh_css"><link href="agg0r_c_files/skypeplugin_dropdownmenu.css" type="text/css" rel="stylesheet" charset="utf-8" id="_skypeplugin_dropdownmenu_css"></head><body alink="#aaaaaa" link="#cc6600" vlink="#ee0099">

<table cellpadding="0" cellspacing="0" width="99%">
 <tbody><tr>
  <td style="color: rgb(170, 0, 170);" width="48%">
      Текст подпрограммы и версий <br>
      <a href="http://www.srcc.msu.su/num_anal/lib_na/cat/ag_c/agg0r_c.zip">agg0r_c.zip</a>&nbsp;
  </td><td style="color: rgb(170, 0, 170);" width="52%">
      Тексты тестовых примеров  <br>
      <a href="http://www.srcc.msu.su/num_anal/lib_na/cat/tag_c/tagg0r_c.zip">tagg0r_c.zip</a>&nbsp;
</td></tr></tbody></table>
<hr>

<h3>Подпрограмма:&nbsp; <span> agg0r_c </span></h3>

<h3>Назначение </h3>
<p> Вычисление всех собственных значений и собственных  вектоpов
   qz - алгоритмом  в обобщенной проблеме собственных значений
   ax&nbsp;=&nbsp;<font face="Symbol">l</font>bx двух вещественных матриц.
   </p>
<h3>Математическое описание </h3>
<p> Алгоритм,  реализованный в подпрограмме  agg0r_c,  может  быть
   разбит на четыре этапа. </p>
<p> Hа первом этапе  преобразованиями  отражения  осуществляется
   одновременное приведение матрицы A к верхней почти
   треугольной форме и матрицы B к верхней треугольной форме. </p>
<p> Hа втоpом этапе при помощи обобщенного неявного  QR -
   алгоритма с двойным сдвигом осуществляется приведение матрицы  A
   к верхней почти треугольной форме (когда нет двух
   последовательных ненулевых поддиагональных  элементов)  с сохранением
   вида матрицы B. </p>
<p> Hа третьем этапе матрица  A  приводится к треугольной форме,
   после   чего  вычисляются   искомые   собственные   значения
   <font face="Symbol">l</font><sub>1</sub>,
   <font face="Symbol">l</font><sub>2</sub>,
    ..., <font face="Symbol">l</font><sub>N</sub>  в  виде     
   <font face="Symbol">l</font><sub>I</sub>&nbsp;=&nbsp;ALFA&nbsp;(I)&nbsp;/&nbsp;BETA&nbsp;(I), 
   когда BETA&nbsp;(I)&nbsp;<font face="Symbol">№</font>&nbsp;0. Если  BETA&nbsp;(I)&nbsp;=&nbsp;0, то
   соответствующее собственное значение 
   <font face="Symbol">l</font><sub>I</sub>
   рассматривавается как бесконечное. </p>
<p> Hа четвертом этапе вычисляются  собственные векторы, которые
   помещаются в комплексной матрице так, что I&nbsp;-&nbsp;й столбец
   содержит собственный  вектоp, соответствующий  I&nbsp;-&nbsp;му
   собственному значению. </p>
<p> C.B.Moler, G.W.Stewart,  An Algorithm for Generalized Matrix
   Eigenvalue Problems, SIAM J.Numer.Anal.10, 1973. </p>

<h3>Использование </h3>
<pre>    int agg0r_c (real *a, real *b, real *v, real *alfa, real *beta,
             real *wk, integer *n, integer *ierr)
</pre>
<pre><h3>   Параметры </h3></pre>
<table cellpadding="6" cellspacing="0" width="99%">
 <tbody><tr>
  <td style="text-align: right;" width="17%">
      a, b      -
  </td><td width="83%">
      вещественные двумерные массивы размера n на
      n, содержащие исходные матрицы  a и b соответственно;
 </td></tr><tr>
  <td style="text-align: right;" width="17%">
      v         -
  </td><td width="83%">
      комплексный двумерный массив размера  n  на
      n, содержащий  вычисленные собственные векторы;
 </td></tr><tr>
  <td style="text-align: right;" width="17%">
      &nbsp;&nbsp;alfa&nbsp;-<br> &nbsp;&nbsp;beta&nbsp;&nbsp;
  </td><td width="83%">
      комплексный и вещественный векторы длины n,
      такие, что искомые собственные значения
      выражаются  через  компоненты  этих  вектоpов
      следующим образом:<br>
      <font face="symbol">l</font><sub>i</sub>&nbsp;=&nbsp;alfa&nbsp;(i)&nbsp;/&nbsp;beta&nbsp;(i);
      если beta&nbsp;(i)&nbsp;=&nbsp;0, то соответствующее
      собственное значение рассматривается  как бесконечное;
 </td></tr><tr>
  <td style="text-align: right;" width="17%">
      wk        -
  </td><td width="83%">
      вещественный  вектоp длины  n, используемый как рабочий;
 </td></tr><tr>
  <td style="text-align: right;" width="17%">
      n         -
  </td><td width="83%">
      заданный порядок исходных матриц  (тип: целый);
 </td></tr><tr>
  <td style="text-align: right;" width="17%">
      ierr      -
  </td><td width="83%">
      целая переменная, служащая для сообщения об
      ошибках, обнаруженных в ходе работы
      подпрограммы;  значение  ierr  полагается  равным
      j+128, где j - номеp собственного значения,
      для вычисления которого потребовалось более
      30 итераций, при этом собственные  значения
      с индексами j+1, ..., n  вычислены правильно,
      а  с индексами  1,&nbsp;...,&nbsp;j  и  соответствующие
      собственные векторы могут быть вычислены не точно.
</td></tr></tbody></table>

<pre><h3>   Версии :  <span> нет </span></h3></pre>

<pre><h3>   Вызываемые подпрограммы </h3></pre>
<table cellpadding="6" cellspacing="0" width="99%">
 <tbody><tr>
  <td style="text-align: right;" width="17%">
      afg3r_c  -
  </td><td width="83%">
      приведение пары  вещественных матриц  a и b  к
      верхней  почти треугольной и треугольной форме
      соответственно ортогональными преобразованиями
      подобия с помощью q*z&nbsp;-&nbsp;алгоритма.
 </td></tr><tr>
  <td style="text-align: right;" width="17%">
      agt0r_c  -
  </td><td width="83%">
      вычисление  всех собственных  значений и
      соответственных вектоpов  qr&nbsp;-&nbsp;алгоритмом в
      обобщенной    проблеме    собственных     значений
      ax&nbsp;=&nbsp;<font face="symbol">l</font>bx
      для верхней почти треугольной и верхней треугольной
      вещественных матриц.
 </td></tr><tr>
  <td style="text-align: right;" width="17%">
      utag10_c -
  </td><td width="83%">
      подпрограмма выдачи  диагностических сообщений
      при работе подпрограммы agg0r_c.
</td></tr></tbody></table>

<pre><h3>   Замечания по использованию  </h3></pre>
<table cellpadding="0" cellspacing="0" width="99%">
 <tbody><tr>
  <td width="2%"> &nbsp;
  </td><td width="98%">
   <p> Исходные матрицы a и b не сохраняются. </p>
   <p> Векторы alfa и beta упорядочены таким образом, что
      комплексно-сопряженные  собственные  значения
      <font face="symbol">l</font><sub>i</sub> и
      <font face="symbol">l</font><sub>i+1</sub>
      расположены последовательно,   т.е.
      alfa&nbsp;(i+1)&nbsp;/&nbsp;beta&nbsp;(i+1)
      комплексно&nbsp;-&nbsp;сопряжено с
      alfa&nbsp;(i)&nbsp;/&nbsp;beta&nbsp;(i).
      При этом alfa&nbsp;(i+1) не обязятельно
      комплексно-сопряжено с alfa&nbsp;(i). </p>
   <p> Собственные  векторы  нормализованы  таким образом, что
      наибольшая компонента по модулю pавна 1. </p>
</td></tr></tbody></table>

<h3>Пример использования </h3>
<pre>int main(void)
{
    /* Initialized data */
    static float a[9] /* was [3][3] */ = { 1.f,-10.f,5.f,.5f,2.f,1.f,0.f,
                                           0.f,.5f };
    static float b[9] /* was [3][3] */ = { .5f,3.f,4.f,0.f,3.f,.5f,0.f,0.f,
                                          1.f };
    /* Local variables */
    static complex alfa[3];
    static float beta[3];
    static int ierr;
    extern int agg0r_c(float *, float *, complex *, complex *, float *,
                       float *, int *, int *);
    static int i__, n;
    static complex v[9] /* was [3][3] */;
    static float wk[3];

#define a_ref(a_1,a_2) a[(a_2)*3 + a_1 - 4]
#define b_ref(a_1,a_2) b[(a_2)*3 + a_1 - 4]
#define v_subscr(a_1,a_2) (a_2)*3 + a_1 - 4
#define v_ref(a_1,a_2) v[v_subscr(a_1,a_2)]

    for (i__ = 1; i__ &lt;= 3; ++i__) {
         printf("\n %12.3e %12.3e %12.3e \n",
                a_ref(i__, 1), a_ref(i__, 2), a_ref(i__, 3));
    }
    for (i__ = 1; i__ &lt;= 3; ++i__) {
         printf("\n %12.3e %12.3e %12.3e \n",
                b_ref(i__, 1), b_ref(i__, 2), b_ref(i__, 3));
    }
    n = 3;
    agg0r_c(a, b, v, alfa, beta, wk, &amp;n, &amp;ierr);

    for (i__ = 1; i__ &lt;= 3; ++i__) {
         printf("\n %12.3e %12.3e %12.3e \n",
                a_ref(i__, 1), a_ref(i__, 2), a_ref(i__, 3));
    }
    for (i__ = 1; i__ &lt;= 3; ++i__) {
         printf("\n %12.3e %12.3e %12.3e \n",
                b_ref(i__, 1), b_ref(i__, 2), b_ref(i__, 3));
    }
    for (i__ = 1; i__ &lt;= 3; ++i__) {
         printf("\n %15.7e %15.7e \n", alfa[i__-1].r, alfa[i__-1].i);
    }
    for (i__ = 1; i__ &lt;= 3; ++i__) {
         printf("\n %15.7e \n", beta[i__-1]);
    }
    for (i__ = 1; i__ &lt;= 3; ++i__) {
         printf("\n %15.7e%15.7e %15.7e%15.7e \n %15.7e%15.7e \n",
           v_ref(i__, 1).r, v_ref(i__, 1).i, v_ref(i__, 2).r, v_ref(i__, 2).i,
           v_ref(i__, 3).r, v_ref(i__, 3).i);
    }
    printf("\n %5i \n", ierr);
    return 0;
} /* main */


Результаты:

      ierr = 0
 
                      | 1.27052+3.03864*i |
      alfa  =  | 0.40869-0.97744*i |
                      | 1.00306+0.00000*i |
 
      beta  =  ( 1.52462,  0.49043,  2.00612 )
</pre>
<p>
   coбcтвeнныe векторы:
  </p>
<pre>               | -0.25205+0.19169*i |
               | -0.25205-0.19169*i |
               |  0.0+0.0*i                 |
               | -0.08799-0.72598*i |
      v  =  | -0.08799+0.72598*i |
               |  0.0+0.0*i                 |
               |  1.00000+0.00000*i |
               |  1.00000-0.00000*i  |
               |  1.0+0.0*i                 |
</pre>
<p>
   coбcтвeнныe значения:
  </p>
<pre>      <font face="symbol">l</font><sub>1</sub>  =  0.83333+1.9930*i
      <font face="symbol">l</font><sub>2</sub>  =  0.83333-1.9930*i
      <font face="symbol">l</font><sub>3</sub>  =  0.50000+0.0000*i
</pre>

</body></html>