<html><head>
<meta http-equiv="content-type" content="text/html; charset=windows-1251">

<title>БЧА НИВЦ МГУ. AEH1R_C. Линейная проблема собственных значений
       для симметричных и эрмитовых матриц</title>
<link rel="stylesheet" href="aeh1r_c_files/sub_dsc.css" type="text/css">
<script charset="utf-8" id="injection_graph_func" src="aeh1r_c_files/injection_graph_func.js"></script><script id="_nameHighlight_injection"></script><link class="skype_name_highlight_style" href="aeh1r_c_files/injection_nh_graph.css" type="text/css" rel="stylesheet" charset="utf-8" id="_injection_graph_nh_css"><link href="aeh1r_c_files/skypeplugin_dropdownmenu.css" type="text/css" rel="stylesheet" charset="utf-8" id="_skypeplugin_dropdownmenu_css"></head><body alink="#aaaaaa" link="#cc6600" vlink="#ee0099">

<table cellpadding="0" cellspacing="0" width="99%">
 <tbody><tr>
  <td style="color: rgb(170, 0, 170);" width="48%">
      Текст подпрограммы и версий <br>
      <a href="http://www.srcc.msu.su/num_anal/lib_na/cat/ae_c/aeh1r_c.zip"> aeh1r_c.zip </a>,
      <a href="http://www.srcc.msu.su/num_anal/lib_na/cat/ae_c/aeh1d_c.zip"> aeh1d_c.zip </a>
  </td><td style="color: rgb(170, 0, 170);" width="52%">
      Тексты тестовых примеров  <br>
      <a href="http://www.srcc.msu.su/num_anal/lib_na/cat/tae_c/taeh1r_c.zip"> taeh1r_c.zip </a>,
      <a href="http://www.srcc.msu.su/num_anal/lib_na/cat/tae_c/taeh1d_c.zip"> taeh1d_c.zip </a>
</td></tr></tbody></table>
<hr>
<h3>Подпрограмма:&nbsp; <span> aeh1r_c </span></h3>

<h3>Назначение </h3>
<p> Вычисление всех собственных значений и соответствующих
   собственных векторов вещественной симметрической матрицы
   ql&nbsp;-&nbsp;алгоритмом со сдвигом. </p>

<h3>Математическое описание </h3>
<p> Заданная матрица ортогональными преобразованиями  приводится
   к трехдиагональной  симметрической  форме,  используемой для
   вычисления собственных значений с помощью  QL&nbsp;-&nbsp;алгоpитма  со
   сдвигом. Информация о преобразованиях  используется  для
   вычисления собственных векторов. </p>
<p> дж.Х.Уилкинсон, Алгебраическая  проблема  собственных
   значений, "Наука", М., 1970. </p>

<h3>Использование </h3>
<pre>    int aeh1r_c (integer *n, real *a, real *ev, real *v, real *
        rab1, integer *ierr)
</pre>
<pre><h3>   Параметры </h3></pre>
<table cellpadding="6" cellspacing="0" width="99%">
 <tbody><tr>
  <td style="text-align: right;" width="17%">
      n    -
  </td><td width="83%">
      порядок исходной матрицы (тип: целый);
 </td></tr><tr>
  <td style="text-align: right;" width="17%">
      a    -
  </td><td width="83%">
      вещественный  двумерный массив  размерности n&nbsp;на&nbsp;n,
      содержащий исходную матрицу;  в подпрограмме
      используется  только полный  нижний  треугольник матрицы&nbsp; a;
 </td></tr><tr>
  <td style="text-align: right;" width="17%">
      ev   -
  </td><td width="83%">
      вещественный  одномерный  массив  размерности&nbsp; n,
      содержащий  вычисленные  собственные   значения,
      расположенные в возрастающем порядке;
 </td></tr><tr>
  <td style="text-align: right;" width="17%">
      v    -
  </td><td width="83%">
      вещественный двумерный массив  размерности  n&nbsp;на&nbsp;n,
      содержащий  вычисленные  ортогональные собственные векторы;
 </td></tr><tr>
  <td style="text-align: right;" width="17%">
      rab  -
  </td><td width="83%">
      вещественный  одномерный  массив  размерности&nbsp; n,
      используемый как рабочий;
 </td></tr><tr>
  <td style="text-align: right;" width="17%">
      ierr -
  </td><td width="83%">
      целая переменная, служащая для сообщения об
      ошибках, обнаруженных  в ходе работы  подпрограммы;
      значение ierr полагается равным номеру
      собственного значения,  для вычисления которого
      потребовалось  более 30 итераций,  при этом  будут
      правильно вычислены, но неупорядочены,  собственные
      значения с индексами 1,&nbsp;2,&nbsp;...,&nbsp;ierr&nbsp;-&nbsp;1 и
      соответствующие собственные векторы.
</td></tr></tbody></table>

<pre><h3>   Версии </h3></pre>
<table cellpadding="6" cellspacing="0" width="99%">
 <tbody><tr>
  <td style="text-align: right;" width="17%">
      aeh1d_c -
  </td><td width="83%">
      вычисление всех собственных значений и
      соответствующих собственных векторов вещественной
      симметрической  матрицы  с  повышенной  точностью.
      Массивы   a,  ev,  v,  rab   имеют  тип  double.
</td></tr></tbody></table>

<pre><h3>   Вызываемые подпрограммы </h3></pre>
<table cellpadding="6" cellspacing="0" width="99%">
 <tbody><tr>
  <td style="text-align: right;" width="17%">
      utae10_c -
  </td><td width="83%">
      подпрограмма выдачи  диагностических сообщений
      при работе подпрограмм aeh1r_c и aeh1d_c.
</td></tr></tbody></table>

<pre><h3>   Замечания по использованию  </h3></pre>
<table cellpadding="0" cellspacing="0" width="99%">
 <tbody><tr>
  <td width="2%">&nbsp;
  </td><td width="98%">
      Подпрограмма aeh1r_c сохраняет исходную матрицу.
</td></tr></tbody></table>

<h3>Пример использования </h3>
<pre>int main(void)
{
    /* Initialized data */
    static float a[16]   /* was [4][4] */ = { 1.f,.42f,.54f,.66f,.42f,1.f,.32f,
                                 .44f,.54f,.32f,1.f,.22f,.66f,.44f,.22f,1.f };
    /* Local variables */
    static int ierr;
    extern int aeh1r_c(int *, float *, float *, float *, float *, int *);
    static int i__;
    static float v[16]   /* was [4][4] */, ev[4], rab[4];

#define a_ref(a_1,a_2) a[(a_2)*4 + a_1 - 5]
#define v_ref(a_1,a_2) v[(a_2)*4 + a_1 - 5]

    for (i__ = 1; i__ &lt;= 4; ++i__) {
        printf("\n %15.3e %15.3e %15.3e %15.3e \n",
            a_ref(i__, 1), a_ref(i__, 2), a_ref(i__, 3), a_ref(i__, 4));
    }
    aeh1r_c(&amp;c__4, a, ev, v, rab, &amp;ierr);

    for (i__ = 1; i__ &lt;= 4; ++i__) {
        printf("\n %15.3e %15.3e %15.3e %15.3e \n",
            a_ref(i__, 1), a_ref(i__, 2), a_ref(i__, 3), a_ref(i__, 4));
    }
    printf("\n %16.7e %16.7e %16.7e %16.7e \n",
            ev[0], ev[1], ev[2], ev[3]);
    for (i__ = 1; i__ &lt;= 4; ++i__) {
        printf("\n %16.7e %16.7e %16.7e %16.7e \n",
            v_ref(i__, 1), v_ref(i__, 2), v_ref(i__, 3), v_ref(i__, 4));
    }
    printf("\n %5i \n", ierr);
    return 0;
} /* main */


Результаты:

       ev(1)  =  0.2422607 , 
       ev(2)  =  0.6382838 , 
       ev(3)  =  0.7967067 , 
       ev(4)  =  2.3227488 ;

       v<sub>1</sub>  =  (0.71884595,  0.09569898,  - 0.38743546,  - 0.5692064) , 
       v<sub>2</sub>  =  (0.38044988,  - 0.85027547,  - 0.0358896059,  0.3619412) , 
       v<sub>3</sub>  =  (- 0.050328449,  0.237226458, - 0.81284617,  0.529595844) , 
       v<sub>4</sub>  =  (- 0.5796425,  - 0.45999666,  - 0.4334591,  - 0.514325614) ;

       ierr  =  0
</pre>

</body></html>